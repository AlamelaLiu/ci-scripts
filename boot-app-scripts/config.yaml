<?xml version='1.0' encoding='UTF-8'?>
<project>
  <actions/>
  <description>BOOT_PXE not supported due to minirootfs change needed;&#xd;
TEST suite only have ltp sysbench smoke by now.&#xd;
WEEKLY_TESTING contains smoke_basic\docker\ftp.</description>
  <keepDependencies>false</keepDependencies>
  <properties>
    <jenkins.model.BuildDiscarderProperty>
      <strategy class="hudson.tasks.LogRotator">
        <daysToKeep>1</daysToKeep>
        <numToKeep>2</numToKeep>
        <artifactDaysToKeep>-1</artifactDaysToKeep>
        <artifactNumToKeep>-1</artifactNumToKeep>
      </strategy>
    </jenkins.model.BuildDiscarderProperty>
    <hudson.plugins.disk__usage.DiskUsageProperty plugin="disk-usage@0.28"/>
    <hudson.model.ParametersDefinitionProperty>
      <parameterDefinitions>
        <hudson.model.StringParameterDefinition>
          <name>TREE_NAME</name>
          <description></description>
          <defaultValue>open-estuary</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>GIT_DESCRIBE</name>
          <description>uefi_b386a15_grub_daac831_kernel_6eade8c</description>
          <defaultValue></defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>SHELL_PLATFORM</name>
          <description>Platform options:
D03 
D05 </description>
          <defaultValue>D05 D03</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>SHELL_DISTRO</name>
          <description>Distro options:
Ubuntu 
CentOS</description>
          <defaultValue>Ubuntu CentOS</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>ARCH_MAP</name>
          <description>Arch_map options:
d03 arm64 
d05 arm64 </description>
          <defaultValue>d05 arm64 d03 arm64</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>BOOT_PLAN</name>
          <description>Boot options:
BOOT_NFS
BOOT_PXE
BOOT_SAS- This will cause all devices of certain device type to be deployed with certain distro.
</description>
          <defaultValue>BOOT_NFS BOOT_SAS</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>APP_PLAN</name>
          <description>App options:
TEST 
WEEKLY_TESTING</description>
          <defaultValue>TEST WEEKLY_TESTING</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>USER</name>
          <description></description>
          <defaultValue>htsat</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>HOST</name>
          <description></description>
          <defaultValue>192.168.3.100</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>LAVA_SERVER</name>
          <description></description>
          <defaultValue>http://192.168.3.100:8089/RPC2</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>LAVA_USER</name>
          <description></description>
          <defaultValue>default</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>LAVA_STREAM</name>
          <description></description>
          <defaultValue>/anonymous/default/</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>LAVA_TOKEN</name>
          <description></description>
          <defaultValue>g43y0wtyi0m2ua7in3xtfch1m2s1dd0k97ac1fqqhqd0qblimtehqkwk8mjimsyh0jczrnaibdlb23mtn17qca6i14tcl27h7md580za5p8w81fl035b6bk1ybw26lle</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>FTP_SERVER</name>
          <description></description>
          <defaultValue>http://192.168.3.100:8083</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>FTP_DIR</name>
          <description></description>
          <defaultValue>/var/www/images/kernel-ci</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>KERNELCI_SERVER</name>
          <description></description>
          <defaultValue>http://192.168.3.100:8888</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>KERNELCI_TOKEN</name>
          <description></description>
          <defaultValue>3eda8013-da37-42ea-b9a0-7a66badd1b68</defaultValue>
        </hudson.model.StringParameterDefinition>
        <hudson.model.StringParameterDefinition>
          <name>TFTP_DIR</name>
          <description></description>
          <defaultValue>/var/lib/tftpboot</defaultValue>
        </hudson.model.StringParameterDefinition>
      </parameterDefinitions>
    </hudson.model.ParametersDefinitionProperty>
  </properties>
  <scm class="hudson.plugins.git.GitSCM" plugin="git@2.5.0">
    <configVersion>2</configVersion>
    <userRemoteConfigs>
      <hudson.plugins.git.UserRemoteConfig>
        <name>origin</name>
        <refspec>+refs/heads/master:refs/remotes/origin/master</refspec>
        <url>https://github.com/donjet/ci-scripts.git</url>
      </hudson.plugins.git.UserRemoteConfig>
    </userRemoteConfigs>
    <branches>
      <hudson.plugins.git.BranchSpec>
        <name>master</name>
      </hudson.plugins.git.BranchSpec>
    </branches>
    <doGenerateSubmoduleConfigurations>false</doGenerateSubmoduleConfigurations>
    <browser class="hudson.plugins.git.browser.AssemblaWeb">
      <url></url>
    </browser>
    <submoduleCfg class="list"/>
    <extensions>
      <hudson.plugins.git.extensions.impl.RelativeTargetDirectory>
        <relativeTargetDir>local/ci-scripts</relativeTargetDir>
      </hudson.plugins.git.extensions.impl.RelativeTargetDirectory>
      <hudson.plugins.git.extensions.impl.CloneOption>
        <shallow>true</shallow>
        <noTags>false</noTags>
        <reference></reference>
        <depth>0</depth>
      </hudson.plugins.git.extensions.impl.CloneOption>
    </extensions>
  </scm>
  <canRoam>true</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenDownstreamBuilding>false</blockBuildWhenDownstreamBuilding>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers/>
  <concurrentBuild>false</concurrentBuild>
  <builders>
    <hudson.tasks.Shell>
      <command>#!/bin/bash

function generate_jobs()
{
	test_name=$1
    distro=$2
    harddisk_flag=$3
    pwd
	for PLAT in $SHELL_PLATFORM 
	do
    	board_arch=${dict[$PLAT]}
        if [ x&quot;$distro&quot; != x&quot;&quot; ]; then
    		python estuary-ci-job-creator.py $FTP_SERVER/${TREE_NAME}/${GIT_DESCRIBE}/${PLAT}-${board_arch}/ --plans $test_name --distro $distro $harddisk_flag --arch ${board_arch}
        else 
        	python estuary-ci-job-creator.py $FTP_SERVER/${TREE_NAME}/${GIT_DESCRIBE}/${PLAT}-${board_arch}/ --plans $test_name --arch ${board_arch}
        fi
        
   		if [ $? -ne 0 ]; then
    		echo &quot;create the boot jobs error! Aborting&quot;
       		return -1
    	fi
	done
}

function run_and_report_jobs()
{
	pushd ${JOBS_DIR}
	python ../estuary-job-runner.py --username $LAVA_USER --token $LAVA_TOKEN --server $LAVA_SERVER --stream $LAVA_STREAM --poll POLL
	popd

	if [ ! -f ${JOBS_DIR}/${RESULTS_DIR}/POLL ]; then
		echo &quot;Running jobs error! Aborting&quot;
    	return -1
	fi

	python estuary-report.py --boot ${JOBS_DIR}/${RESULTS_DIR}/POLL --lab $LAVA_USER

	if [ ! -d ${RESULTS_DIR} ]; then
		echo &quot;running jobs error! Aborting&quot; 
		return -1
	fi
}

function judge_pass_or_not()
{
	FAIL_FLAG=$(grep -R &apos;FAIL&apos; ./${JOBS_DIR}/${RESULTS_DIR}/POLL)
	if [ &quot;$FAIL_FLAG&quot;x != &quot;&quot;x ]; then
		echo &quot;jobs fail&quot;
	    return -1
	fi

	PASS_FLAG=$(grep -R &apos;PASS&apos; ./${JOBS_DIR}/${RESULTS_DIR}/POLL)
	if [ &quot;$PASS_FLAG&quot;x = &quot;&quot;x ]; then
		echo &quot;jobs fail&quot;
	    return -1
	fi
}

function run_and_move_result()
{
	test_name=$1
    dest_dir=$2

    ret_val=0
    run_and_report_jobs
	if [ $? -ne 0 ] ;then
        ret_val=-1
	fi
    
	judge_pass_or_not
	if [ $? -ne 0 ] ; then
    	ret_val=-1
    fi
	
	[ -d ${JOBS_DIR} ] &amp;&amp; mv ${JOBS_DIR} ${JOBS_DIR}_${test_name}
    [ -d ${RESULTS_DIR} ] &amp;&amp; mv ${RESULTS_DIR} ${RESULTS_DIR}_${test_name}
    
    [ ! -d ${dest_dir} ] &amp;&amp; mkdir -p ${dest_dir}
    [ -d ${JOBS_DIR}_${test_name} ] &amp;&amp; mv ${JOBS_DIR}_${test_name} ${dest_dir}
	[ -d ${RESULTS_DIR}_${test_name} ] &amp;&amp; mv ${RESULTS_DIR}_${test_name} ${dest_dir}
    
    if [ &quot;$ret_val&quot; -ne 0 ]; then
    	return -1
    else
    	return 0
    fi
}

function print_time()
{
	echo -e &quot;@@@@@@&quot;$@ `date &quot;+%Y-%m-%d %H:%M:%S&quot;` &quot;\n&quot; &gt;&gt; $timefile
    #echo -e &quot;\n&quot;  &gt;&gt; $timefile
}

export

#######  Begining the tests ######
timefile=${WORKSPACE}/timestamp_boot.txt
if [ -f ${timefile} ]; then
	rm -fr $timefile
else
	touch $timefile
fi

if [ -f ${WORKSPACE}/whole_summary.txt ]; then
	rm -rf ${WORKSPACE}/whole_summary.txt
else
	touch ${WORKSPACE}/whole_summary.txt
fi 


print_time &quot;the begin time of boot test is &quot;

##### copy some files to the lava-server machine to support the boot process #####
set -e
set -x

CI_SCRIPTS_DIR=${WORKSPACE}/local/ci-scripts
pushd ${CI_SCRIPTS_DIR}/boot-app-scripts    # change current work directory


test -d $GIT_DESCRIBE &amp;&amp; rm -fr $GIT_DESCRIBE

echo $TFTP_DIR
cp download_all_file.py download_distros.sh $TFTP_DIR


if [ $? -ne 0 ]; then
	echo &apos;Upload download tools failed&apos;
    exit -1
fi

ESTUARY_DIR=estuary
BOOT_LOC=/targetNFS/ubuntu_for_deployment/sys_setup/bin
BOOT_DIR=/targetNFS/ubuntu_for_deployment/sys_setup/boot
ESTUARY_CI_DIR=estuary_ci_files
JOBS_DIR=jobs
RESULTS_DIR=results

(
    cd $TFTP_DIR
    [ -d ${ESTUARY_DIR} ] &amp;&amp; rm -fr ${ESTUARY_DIR}
    mkdir ${ESTUARY_DIR}
    
	cd $TFTP_DIR/${ESTUARY_DIR}
    python ../download_all_file.py -u $FTP_SERVER -d $GIT_DESCRIBE -j $TREE_NAME
    
    SATA_IMAGE_DIR=sata_image
    [ -d ${SATA_IMAGE_DIR} ] &amp;&amp; rm -fr ${SATA_IMAGE_DIR}
    mkdir ${SATA_IMAGE_DIR}
    
    for file in *; do
    	if [ x&quot;$(expr match &quot;$file&quot; &apos;.*\(-sata\).*&apos;)&quot; != x&quot;&quot; ]; then
        	mv $file ./${SATA_IMAGE_DIR}/${file/-sata/}
        fi
    done
    
    [ -d /home/$USER/${ESTUARY_CI_DIR} ] &amp;&amp; sudo rm -fr /home/$USER/${ESTUARY_CI_DIR}
    sudo mkdir /home/$USER/${ESTUARY_CI_DIR}
   
    if [[ ${SHELL_PLATFORM} =~ &quot;D02&quot; ]] || [[ ${SHELL_PLATFORM} =~ &quot;d02&quot; ]];then 
    
    sudo cp -rf *dtb *Image* mini* ${SATA_IMAGE_DIR} /home/$USER/${ESTUARY_CI_DIR}
    else
    
    sudo cp -rf *Image* mini* ${SATA_IMAGE_DIR} /home/$USER/${ESTUARY_CI_DIR}
    fi
    
	#sudo cp -rf *dtb *Image* mini* ${SATA_IMAGE_DIR} /home/$USER/${ESTUARY_CI_DIR}
    
    rm -fr download_all_file.py
)

(
    cd $TFTP_DIR/${ESTUARY_DIR}
	if [ ${SHELL_PLATFORM} =~ &quot;D02&quot; -o ${SHELL_PLATFORM} =~ &quot;d02&quot; ];then 
    echo &quot;SHELL_PLATFORM = D02&quot;
    sudo cp -f *.dtb *Image* $BOOT_LOC
    sudo cp -f *.dtb *Image* $BOOT_DIR
    else
    echo &quot;SHELL_PLATFORM &gt;= D03&quot;
    sudo cp -f  *Image* $BOOT_LOC
    sudo cp -f  *Image* $BOOT_DIR    
    fi
)

read -a arch &lt;&lt;&lt; $(echo $ARCH_MAP)
declare -A dict
for((i=0; i&lt;${#arch[@]}; i++))
do
    if ((i%2==0)); then
        j=`expr $i+1`
        dict[${arch[$i]}]=${arch[$j]}
    fi
done

SHELL_PLATFORM=&quot;$(echo $SHELL_PLATFORM | tr &apos;[:upper:]&apos; &apos;[:lower:]&apos;)&quot;

for DISTRO in $SHELL_DISTRO;
do
	for PLAT in $SHELL_PLATFORM;
    do
    	board_arch=${dict[$PLAT]}
        URL_NAME=$FTP_SERVER/${TREE_NAME}/${GIT_DESCRIBE}/${PLAT}-${board_arch}
        (
            cd $TFTP_DIR
            sudo ./download_distros.sh $DISTRO $URL_NAME ${board_arch} $PLAT
        )
    done
done

set +e
##### Finish copying files to the lava-server machine #####

rm -fr jobs*
rm -fr results*

[ -d $GIT_DESCRIBE ] &amp;&amp; rm -fr $GIT_DESCRIBE
mkdir -p $GIT_DESCRIBE/${RESULTS_DIR}

print_time &quot;the time of preparing all envireonment is &quot;

set -x

for DISTRO in $SHELL_DISTRO; 
do
	if [ -d $DISTRO ];then
    	rm -fr $DISTRO
    fi
    mkdir $DISTRO

	for boot_plan in $BOOT_PLAN;
    do
   		rm -fr ${JOBS_DIR} ${RESULTS_DIR}
        
		# generate the boot jobs for all the targets
		if [ &quot;$boot_plan&quot; = &quot;BOOT_SAS&quot; ]  || [ &quot;$boot_plan&quot; = &quot;BOOT_SATA&quot; ]; then
			generate_jobs &quot;boot&quot; $DISTRO
        	[ $? -ne 0 ] &amp;&amp; continue

			# create the boot jobs for each target and run all these jobs
        	cd ${JOBS_DIR}
        	ls
			python ../create_boot_job.py --username $LAVA_USER --token $LAVA_TOKEN --server $LAVA_SERVER --stream $LAVA_STREAM
			if [ $? -ne 0 ]; then
				echo &quot;generate the jobs according the board devices error! Aborting&quot;
				continue
			fi

			cd ..
        	run_and_move_result &quot;boot&quot; $DISTRO
        	if [ $? -ne 0 ] ;then
            	python parser.py -d $DISTRO 
            	if [ ! -d $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO} ];then
            		mv ${DISTRO} $GIT_DESCRIBE/${RESULTS_DIR}/ &amp;&amp; continue
            	else
            		cp -fr ${DISTRO}/* $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO}/ &amp;&amp; continue
                fi
            fi
            
			print_time &quot;the end time of deploy $DISTRO in HD through NFS is &quot;
            
    		#########################################
			##### Entering the sata disk rootfs #####
			# generate the boot jobs for one target
    		BOOT_FOR_TEST=BOOT_SAS
    		rm -fr ${JOBS_DIR} ${RESULTS_DIR}
            
    		generate_jobs ${BOOT_FOR_TEST} $DISTRO &quot;--SasFlag&quot;
    	
        	[ $? -ne 0 ] &amp;&amp; continue
        	cd ${JOBS_DIR}
			python ../create_boot_job.py --username $LAVA_USER --token $LAVA_TOKEN --server $LAVA_SERVER --stream $LAVA_STREAM
			if [ $? -ne 0 ]; then
				echo &quot;generate the jobs according the board devices error! Aborting&quot;
    	    	continue 
			fi
        
        	cd ..
    		if [ -d ${JOBS_DIR} ]; then
				run_and_move_result ${BOOT_FOR_TEST} $DISTRO    			     
				if [ $? -ne 0 ] ;then
                	python parser.py -d $DISTRO 
                	if [ ! -d $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO} ];then
            			mv ${DISTRO} $GIT_DESCRIBE/${RESULTS_DIR} &amp;&amp; continue
            		else
            			cp -fr ${DISTRO}/* $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO}/ &amp;&amp; continue
            		fi
                fi
			fi
    
    		print_time &quot;the end time of boot $DISTRO from HD is &quot;
			##### End of entering the sata disk #####
            
            if [ x&quot;$APP_PLAN&quot; != x ] ; then
            	#####  modify the ip address according to the boot information
    			DEVICE_IP=&apos;device_ip_type.txt&apos;
    			rm -fr /etc/lava-dispatcher/devices/$DEVICE_IP
    			cat $DISTRO/${RESULTS_DIR}_${BOOT_FOR_TEST}/${LAVA_USER}/${DEVICE_IP}
    			cp $DISTRO/${RESULTS_DIR}_${BOOT_FOR_TEST}/${LAVA_USER}/${DEVICE_IP} /etc/lava-dispatcher/devices
    			cp modify_conf_file.sh /etc/lava-dispatcher/devices
    			cd /etc/lava-dispatcher/devices; ./modify_conf_file.sh; cd -
    			sudo rm -fr $HOME/.ssh/known_hosts
    
    			if [ $? -ne 0 ]; then
    				echo &quot;create ip and host mapping error! Aborting&quot;
       				python parser.py  -d $DISTRO  
        			if [ ! -d $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO} ];then
            			mv ${DISTRO} $GIT_DESCRIBE/${RESULTS_DIR} &amp;&amp; continue
        			else
        				cp -fr ${DISTRO}/* $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO}/ &amp;&amp; continue
        			fi
    			fi

				rm -fr ${JOBS_DIR} ${RESULTS_DIR}
				# generate the application jobs for the board_types 
				for app_plan in $APP_PLAN
				do
					[[ $app_plan =~ &quot;BOOT&quot; ]] &amp;&amp; continue
        
    				generate_jobs $app_plan $DISTRO
        			if [ $? -ne 0 ] ;then
            			python parser.py -d $DISTRO 
            			if [ ! -d $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO} ];then
            				mv ${DISTRO} $GIT_DESCRIBE/${RESULTS_DIR}/ &amp;&amp; continue
            			else
            				cp -fr ${DISTRO}/* $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO}/ &amp;&amp; continue
                		fi
            		fi
				done
    
				if [ -d ${JOBS_DIR} ]; then
        			run_and_report_jobs
	    			test -d ${RESULTS_DIR}  &amp;&amp; mv ${RESULTS_DIR} ${RESULTS_DIR}_app
	    			test -d ${JOBS_DIR}  &amp;&amp; mv ${JOBS_DIR} ${JOBS_DIR}_app
        			[ ! -d $DISTRO ] &amp;&amp; mkdir -p $DISTRO
        			test -d ${JOBS_DIR}_app &amp;&amp; mv ${JOBS_DIR}_app $DISTRO
	    			test -d ${RESULTS_DIR}_app &amp;&amp; mv ${RESULTS_DIR}_app $DISTRO
        
					if [ $? -ne 0 ] ;then
            			python parser.py -d $DISTRO 
            			if [ ! -d $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO} ];then
            				mv ${DISTRO} $GIT_DESCRIBE/${RESULTS_DIR}/ &amp;&amp; continue
            			else
            				cp -fr ${DISTRO}/* $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO}/ &amp;&amp; continue
                		fi
            		fi
		
        			print_time &quot;the end time of running app of $DISTRO is &quot;
    			fi     
			fi
                        
    	else
         	print_time &quot;the start time of $boot_plan is &quot;
            rm -fr ${JOBS_DIR} ${RESULTS_DIR}
           
    		generate_jobs $boot_plan $DISTRO
        	[ $? -ne 0 ] &amp;&amp; python parser.py -d $DISTRO &amp;&amp; mv $DISTRO $GIT_DESCRIBE/${RESULTS_DIR} &amp;&amp; continue 
		
        	if [ -d ${JOBS_DIR} ]; then
        		run_and_move_result $boot_plan $DISTRO		        
				if [ $? -ne 0 ] ;then
                	python parser.py -d $DISTRO 
                	if [ ! -d $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO} ];then
            			mv ${DISTRO} $GIT_DESCRIBE/${RESULTS_DIR} &amp;&amp; continue
            		else
            			cp -fr ${DISTRO}/* $GIT_DESCRIBE/${RESULTS_DIR}/${DISTRO}/ &amp;&amp; continue
            		fi
                fi
			fi
            
            print_time &quot;the end time of $boot_plan is &quot;
         fi 
    done
    python parser.py -d $DISTRO
    mv $DISTRO $GIT_DESCRIBE/${RESULTS_DIR}

done
##################################

#DES_TMP=boot_results
#[ -d $DES_TMP ] &amp;&amp; rm -fr $DES_TMP
#mkdir $DES_TMP

#rm -fr ${JOBS_DIR} ${RESULTS_DIR}
# generate the boot jobs for the board_types 
#for app_plan in $APP_PLAN
#do
#    [[ $app_plan =~ &quot;BOOT&quot; ]] &amp;&amp; generate_jobs $app_plan
#    [ ! -d ${JOBS_DIR} ] &amp;&amp; continue
#done

#if [ -d ${JOBS_DIR} ]; then
#	run_and_report_jobs 
#	[ $? -ne 0 ] &amp;&amp; exit -1
#    
#	test -d ${JOBS_DIR} &amp;&amp; mv ${JOBS_DIR} $DES_TMP
#	test -d ${RESULTS_DIR} &amp;&amp; mv ${RESULTS_DIR} $DES_TMP
#    
#    python parser.py -d $DES_TMP
#    mv $DES_TMP $GIT_DESCRIBE/${RESULTS_DIR}
#    
#    print_time &quot;the end time of running boot tasks is &quot;
#fi 
##################################

# push the binary files to the ftpserver
#sudo python publish.py -j $TREE_NAME -d ./$GIT_DESCRIBE
DES_DIR=$FTP_DIR/$TREE_NAME/$GIT_DESCRIBE/
[ ! -d $DES_DIR ] &amp;&amp; echo &quot;Don&apos;t have the images and dtbs&quot; &amp;&amp; exit -1

pushd $GIT_DESCRIBE
python ../parser.py -s ${RESULTS_DIR}
popd

tar czf test_result.tar.gz $GIT_DESCRIBE/*
cp test_result.tar.gz  ${WORKSPACE}


WHOLE_SUM=&apos;whole_summary.txt&apos;
if [  -e  ${WORKSPACE}/${WHOLE_SUM} ]; then
	rm -rf  ${WORKSPACE}/${WHOLE_SUM}
fi
cp $GIT_DESCRIBE/${RESULTS_DIR}/${WHOLE_SUM} ${WORKSPACE}
cp -rf $timefile ${WORKSPACE}


#zip -r ${GIT_DESCRIBE}_results.zip $GIT_DESCRIBE/*
cp -f $timefile $GIT_DESCRIBE

if [ -d $DES_DIR/$GIT_DESCRIBE/results ];then
	sudo rm -fr $DES_DIR/$GIT_DESCRIBE/results
    sudo rm -fr $DES_DIR/$GIT_DESCRIBE/$timefile
fi
sudo cp -rf $GIT_DESCRIBE/* $DES_DIR
[ $? -ne 0 ]&amp;&amp; exit -1

popd    # restore current work directory


cat ${WORKSPACE}/timestamp_boot.txt

if [ x&quot;$BUILD_STATUS&quot; != x&quot;Successful&quot;  ]; then
BUILD_RESULT=${BUILD_STATUS}
else
BUILD_RESULT=Failure
fi
</command>
    </hudson.tasks.Shell>
  </builders>
  <publishers>
    <hudson.plugins.emailext.ExtendedEmailPublisher plugin="email-ext@2.44">
      <recipientList>donald.liujie@huawei.com;meili760628705@163.com</recipientList>
      <configuredTriggers>
        <hudson.plugins.emailext.plugins.trigger.FailureTrigger>
          <email>
            <subject>$PROJECT_DEFAULT_SUBJECT</subject>
            <body>$PROJECT_DEFAULT_CONTENT</body>
            <recipientProviders>
              <hudson.plugins.emailext.plugins.recipients.DevelopersRecipientProvider/>
              <hudson.plugins.emailext.plugins.recipients.ListRecipientProvider/>
            </recipientProviders>
            <attachmentsPattern></attachmentsPattern>
            <attachBuildLog>false</attachBuildLog>
            <compressBuildLog>false</compressBuildLog>
            <replyTo>$PROJECT_DEFAULT_REPLYTO</replyTo>
            <contentType>project</contentType>
          </email>
        </hudson.plugins.emailext.plugins.trigger.FailureTrigger>
        <hudson.plugins.emailext.plugins.trigger.AlwaysTrigger>
          <email>
            <subject>$PROJECT_DEFAULT_SUBJECT</subject>
            <body>$PROJECT_DEFAULT_CONTENT</body>
            <recipientProviders>
              <hudson.plugins.emailext.plugins.recipients.DevelopersRecipientProvider/>
              <hudson.plugins.emailext.plugins.recipients.ListRecipientProvider/>
            </recipientProviders>
            <attachmentsPattern></attachmentsPattern>
            <attachBuildLog>false</attachBuildLog>
            <compressBuildLog>false</compressBuildLog>
            <replyTo>$PROJECT_DEFAULT_REPLYTO</replyTo>
            <contentType>project</contentType>
          </email>
        </hudson.plugins.emailext.plugins.trigger.AlwaysTrigger>
      </configuredTriggers>
      <contentType>text/plain</contentType>
      <defaultSubject>Estuary Boot - ${GIT_DESCRIBE} - Result</defaultSubject>
      <defaultContent>( This mail is send by Jenkins automatically, don&apos;t reply )
Project Name: $PROJECT_NAME
Version: ${GIT_DESCRIBE}
Boot and Test Status: $BUILD_STATUS
Trigger Reason: ${CAUSE}
Build Log Address: ${BUILD_URL}console
Build Project Address: $BUILD_URL
Build and Generated Binaries Address: http://114.119.4.74:8083/open-estuary/${GIT_DESCRIBE}
The Test Cases Definition Address: https://github.com/open-estuary/ci-test-cases

Test summary is below:
${FILE,path=&quot;whole_summary.txt&quot;}


The test time stamp is below:
${FILE,path=&quot;timestamp_boot.txt&quot;}</defaultContent>
      <attachmentsPattern>test_result.tar.gz</attachmentsPattern>
      <presendScript>$DEFAULT_PRESEND_SCRIPT</presendScript>
      <postsendScript>$DEFAULT_POSTSEND_SCRIPT</postsendScript>
      <attachBuildLog>false</attachBuildLog>
      <compressBuildLog>false</compressBuildLog>
      <replyTo>$DEFAULT_REPLYTO;</replyTo>
      <saveOutput>false</saveOutput>
      <disabled>false</disabled>
    </hudson.plugins.emailext.ExtendedEmailPublisher>
  </publishers>
  <buildWrappers>
    <hudson.plugins.timestamper.TimestamperBuildWrapper plugin="timestamper@1.8.3"/>
  </buildWrappers>
</project>